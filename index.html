<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Port√°l Pro</title>
    <style>
        :root {
            --bg-color: #121212; --primary-color: #1e1e1e; --secondary-color: #2a2a2a;
            --font-color: #e0e0e0; --accent-color: #03dac6; --border-color: #333;
        }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--font-color); margin: 0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { background: var(--primary-color); padding: 30px; border-radius: 12px; margin-bottom: 30px; }
        h1 { text-align: center; margin: 0 0 30px 0; font-size: 2.5em; font-weight: 300; color: var(--accent-color); }
        .button-group { display: flex; gap: 15px; }
        textarea { width: 100%; min-height: 100px; background: var(--secondary-color); border: 1px solid var(--border-color); color: var(--font-color); border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        button { padding: 12px 20px; background-color: var(--accent-color); color: var(--bg-color); border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; flex-grow: 1; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        .provider-selection, .channel-section { background: var(--primary-color); padding: 25px; border-radius: 12px; margin-bottom: 30px; }
        .provider-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; }
        .provider-card { background: var(--secondary-color); padding: 15px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.3s; }
        .provider-card.selected { border-color: var(--accent-color); }
        .channel-filters { display: flex; gap: 15px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        select, input { background: var(--secondary-color); border: 1px solid var(--border-color); color: var(--font-color); padding: 8px 12px; border-radius: 6px; }
        
        /* === Lazy Loading & Performance === */
        .category-placeholder { min-height: 300px; /* Aby se observer spustil */ }
        .category-container h2 { border-bottom: 2px solid var(--accent-color); padding-bottom: 10px; margin-bottom: 20px; }
        .channel-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
        
        .channel { background: var(--secondary-color); text-align: center; padding: 15px; border-radius: 8px; cursor: pointer; transition: transform 0.2s; }
        .channel:hover { transform: translateY(-5px); }
        .channel-logo { width: 60px; height: 60px; object-fit: contain; margin-bottom: 10px; }
        .source-badge { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #444; margin: 0 2px; }
        .loader { border: 6px solid var(--secondary-color); border-top: 6px solid var(--accent-color); border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 50px auto; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); }
        .modal-content { background: var(--primary-color); margin: 10% auto; padding: 20px; width: 90%; max-width: 600px; border-radius: 8px; }
        .epg-item { padding: 10px; border-bottom: 1px solid var(--secondary-color); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé¨ IPTV Port√°l Pro</h1>
            <textarea id="manualUrls" placeholder="Vlo≈æte manu√°ln√≠ M3U_PLUS odkazy (ka≈æd√Ω na nov√Ω ≈ô√°dek)"></textarea>
            <div class="button-group">
                <button id="loadDataBtn">üîç Naƒç√≠st data</button>
                <button id="showInfoBtn" disabled>‚ÑπÔ∏è Info o √∫ƒçtech</button>
            </div>
        </header>

        <div id="providerSelection" style="display:none;">
            <h2>üì° Vyberte poskytovatele</h2>
            <div id="providerGrid" class="provider-grid"></div>
            <button id="showChannelsBtn" style="width:100%; margin-top:15px;" disabled>üì∫ Zobrazit kan√°ly</button>
        </div>

        <div id="channelSection" style="display:none;">
            <div class="channel-filters">
                <select id="comparisonFilter" disabled><option value="all">V≈°echny kan√°ly</option><option value="shared">Pouze sd√≠len√©</option><option value="unique">Pouze unik√°tn√≠</option></select>
                <select id="categoryFilter"><option value="all">V≈°echny kategorie</option></select>
                <input type="text" id="searchFilter" placeholder="Hledat kan√°l...">
            </div>
            <div id="channelList"></div>
        </div>
        
        <div id="loader" style="display: none;"></div>
    </div>

    <div id="epgModal" class="modal">
        <div class="modal-content">
            <h2 id="epgChannelName"></h2>
            <div id="epgList" style="max-height: 400px; overflow-y: auto;"></div>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Elementy ---
        const loadDataBtn = document.getElementById('loadDataBtn');
        const manualUrlsInput = document.getElementById('manualUrls');
        const providerSelectionDiv = document.getElementById('providerSelection');
        const providerGrid = document.getElementById('providerGrid');
        const showChannelsBtn = document.getElementById('showChannelsBtn');
        const channelSectionDiv = document.getElementById('channelSection');
        const channelListDiv = document.getElementById('channelList');
        const loader = document.getElementById('loader');
        const comparisonFilter = document.getElementById('comparisonFilter');
        const categoryFilter = document.getElementById('categoryFilter');
        const searchFilter = document.getElementById('searchFilter');
        const showInfoBtn = document.getElementById('showInfoBtn');

        // --- Stav Aplikace ---
        let allProviders = [];
        let selectedProviders = new Map();
        let allChannelsData = {};
        let filteredChannelsData = {};
        let intersectionObserver;

        // --- Event Listeners ---
        loadDataBtn.addEventListener('click', loadProviders);
        showChannelsBtn.addEventListener('click', prepareChannelView);
        [comparisonFilter, categoryFilter, searchFilter].forEach(el => el.addEventListener('input', debounce(applyFilters, 300)));
        window.addEventListener('click', (e) => { if(e.target.classList.contains('modal')) e.target.style.display = 'none' });

        // --- Logika Aplikace ---

        async function loadProviders() {
            loader.style.display = 'block';
            [providerSelectionDiv, channelSectionDiv].forEach(el => el.style.display = 'none');
            providerGrid.innerHTML = '';
            
            try {
                const manual_urls = manualUrlsInput.value.split('\n').filter(Boolean);
                const response = await fetch('/api/getChannels', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ manual_urls }),
                });
                if (!response.ok) throw new Error((await response.json()).error || 'Chyba serveru');
                
                const responseData = await response.json();
                if (responseData._metadata.errors.length) console.warn('Chyby p≈ôi naƒç√≠t√°n√≠:', responseData._metadata.errors);
                delete responseData._metadata;
                allChannelsData = responseData;

                const providerMap = new Map();
                Object.values(allChannelsData).flat().forEach(ch => ch.sources.forEach(s => {
                    if (!providerMap.has(s.provider.server)) providerMap.set(s.provider.server, { ...s.provider, channelCount: 0 });
                    providerMap.get(s.provider.server).channelCount++;
                }));
                allProviders = [...providerMap.values()];
                
                displayProviders();
                providerSelectionDiv.style.display = 'block';

            } catch (error) {
                console.error('Nepoda≈ôilo se naƒç√≠st poskytovatele:', error);
                providerGrid.innerHTML = `<p style="color:red;">${error.message}</p>`;
            } finally {
                loader.style.display = 'none';
            }
        }

        function displayProviders() {
            providerGrid.innerHTML = allProviders.map((p, i) => `
                <div class="provider-card" data-provider-index="${i}">
                    <strong>${p.hostname}</strong><br>
                    <small>${p.isFromAPI ? 'API' : 'Manu√°ln√≠'} | ${p.channelCount} kan√°l≈Ø</small>
                </div>`).join('');
            
            providerGrid.querySelectorAll('.provider-card').forEach(card => card.addEventListener('click', toggleProviderSelection));
        }

        function toggleProviderSelection(event) {
            const card = event.currentTarget;
            const index = card.dataset.providerIndex;
            const provider = allProviders[index];
            
            card.classList.toggle('selected');
            if (selectedProviders.has(provider.server)) {
                selectedProviders.delete(provider.server);
            } else {
                selectedProviders.set(provider.server, provider);
            }
            showChannelsBtn.disabled = selectedProviders.size === 0;
            showInfoBtn.disabled = selectedProviders.size === 0;
            comparisonFilter.disabled = selectedProviders.size < 2;
        }

        function prepareChannelView() {
            populateCategoryFilter();
            applyFilters();
            channelSectionDiv.style.display = 'block';
        }

        function populateCategoryFilter() {
            const categories = new Set();
            Object.values(allChannelsData).flat().forEach(ch => {
                if(ch.sources.some(s => selectedProviders.has(s.provider.server))) {
                    categories.add(ch.category);
                }
            });
            categoryFilter.innerHTML = '<option value="all">V≈°echny kategorie</option>' + 
                [...categories].sort().map(c => `<option value="${c}">${c}</option>`).join('');
        }

        function applyFilters() {
            filteredChannelsData = {};
            const search = searchFilter.value.toLowerCase().trim();

            Object.entries(allChannelsData).forEach(([cat, channels]) => {
                if (categoryFilter.value !== 'all' && cat !== categoryFilter.value) return;

                const filtered = channels
                    .map(ch => ({ ...ch, sources: ch.sources.filter(s => selectedProviders.has(s.provider.server)) }))
                    .filter(ch => {
                        if (ch.sources.length === 0) return false;
                        if (search && !ch.name.toLowerCase().includes(search)) return false;
                        if (comparisonFilter.value === 'shared' && ch.sources.length < selectedProviders.size) return false;
                        if (comparisonFilter.value === 'unique' && ch.sources.length > 1) return false;
                        return true;
                    });
                
                if (filtered.length > 0) filteredChannelsData[cat] = filtered;
            });
            displayChannelPlaceholders();
        }

        function displayChannelPlaceholders() {
            if (intersectionObserver) intersectionObserver.disconnect();
            channelListDiv.innerHTML = '';

            const categories = Object.keys(filteredChannelsData);
            if(categories.length === 0) {
                 channelListDiv.innerHTML = `<div class="empty-state">≈Ω√°dn√© kan√°ly nevyhovuj√≠ filtr≈Øm.</div>`;
                 return;
            }

            intersectionObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const placeholder = entry.target;
                        const categoryName = placeholder.dataset.category;
                        renderCategory(placeholder, categoryName);
                        observer.unobserve(placeholder);
                    }
                });
            }, { rootMargin: "200px" });

            categories.forEach(cat => {
                const placeholder = document.createElement('div');
                placeholder.className = 'category-placeholder';
                placeholder.dataset.category = cat;
                channelListDiv.appendChild(placeholder);
                intersectionObserver.observe(placeholder);
            });
        }

        function renderCategory(placeholder, categoryName) {
            const channels = filteredChannelsData[categoryName];
            const container = document.createElement('div');
            container.className = 'category-container';
            container.innerHTML = `<h2>${categoryName} (${channels.length})</h2>
                <div class="channel-grid">
                    ${channels.map(ch => `
                        <div class="channel" data-category="${escape(ch.category)}" data-channel-name="${escape(ch.name)}">
                            <img class="channel-logo" src="${ch.logo || ''}" onerror="this.style.display='none'">
                            <div>${ch.name}</div>
                            <div>${ch.sources.map(s => `<span class="source-badge">${s.provider.hostname.split('.')[0]}</span>`).join('')}</div>
                        </div>
                    `).join('')}
                </div>`;
            placeholder.replaceWith(container);
            container.querySelectorAll('.channel').forEach(c => c.addEventListener('click', onChannelClick));
        }
        
        async function onChannelClick(event) {
            const el = event.currentTarget;
            const category = unescape(el.dataset.category);
            const name = unescape(el.dataset.channelName);
            const channel = filteredChannelsData[category].find(ch => ch.name === name);
            
            // Logika pro EPG
            const source = channel.sources[0]; // Zobraz√≠me EPG pro prvn√≠ zdroj
            const epgModal = document.getElementById('epgModal');
            document.getElementById('epgChannelName').textContent = channel.name;
            const epgList = document.getElementById('epgList');
            epgList.innerHTML = '<div class="loader"></div>';
            epgModal.style.display = 'block';

            try {
                const res = await fetch('/api/getEpg', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ channelId: source.id, provider: source.provider })
                });
                if(!res.ok) throw new Error(await res.text());
                const epgData = await res.json();
                
                // **OPRAVA ZOBRAZEN√ç EPG**
                if (!epgData || !epgData.epg_listings || epgData.epg_listings.length === 0) {
                    epgList.innerHTML = '≈Ω√°dn√° data programu.';
                    return;
                }
                epgList.innerHTML = epgData.epg_listings.map(p => {
                     const start = new Date(parseInt(p.start_timestamp) * 1000);
                     const end = new Date(parseInt(p.end_timestamp) * 1000);
                     const title = atob(p.title);
                     const desc = p.description ? atob(p.description) : '';
                     return `<div class="epg-item">
                                <strong>${start.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} - ${end.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</strong><br>
                                ${title}<br>
                                <small>${desc}</small>
                            </div>`
                }).join('');

            } catch(e) {
                epgList.innerHTML = `Chyba naƒç√≠t√°n√≠ EPG: ${e.message}`;
            }
        }
        
        function debounce(func, delay) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
    });
    </script>
</body>
</html>
